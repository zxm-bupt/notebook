

# 1. 综述

# 2. TCP协议

## 2.1 TCP的包头

<img src="http://123.57.190.49:12121/api/image/R0N0NRH8.jpg" title="" alt="" data-align="center">

* 源端口：16位，标识报文的返回地址。

* 目的端口：16位，指明接收方计算机上的应用程序接口。

* 序号：seq，32位，在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就**累加**一次该**数据字节数**的大小。用来解决网络包乱序问题。，发送方和接收方通过seq与ack来进行保证发送与接收的顺序，不带数据的ack包，不占用序列号，第三次握手，不带序号的话，不占用序列化号。其他包，均会占用序列号。

* 确认号：ack，32位，指下一次**期望**收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。32位，指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。

* 数据偏移：offset，4位，TCP首部可能含有可选项内容，所以TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示最大长度为60字节。首部长度也叫数据偏移，因为首部长度实际上指示了数据区在报文段中的起始偏移值。

* 保留：6位，为将来定义新的用途保留，现在一般置0。

* 标志位：6位
  
  * **URG**：紧急指针标志，为1时表示紧急指针有效，**该报文应该优先传送**，为0则忽略紧急指针。
  
  * **ACK**：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息。携带ACK标识的TCP报文段被称为**确认报文段**。
  
  * **RST**：重置连接标志，**用于重置由于主机崩溃或其他原因而出现错误的连接，或者用于拒绝非法的报文段和拒绝连接请求**。称携带RST标志的TCP报文段为复位报文段。
  
  * **SYN**：表示请求建立一个连接。称携带SYN标志的TCP报文段为同步报文段。
  
  * **FIN**：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。称携带FIN标志的TCP报文段为结束报文段。
  
  * **PSH**：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应优先将这个报文段交给应用程序，而不是在缓冲区排队。

* 窗口：16位，是TCP流量控制的一个手段。通过窗口告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方可以控制发送数据的速度，从而达到流量控制。窗口大小为16bit字段，因而窗口大小最大为65535。TCP发送时，会给很具该窗口和拥塞窗口来进行判断，发送数据可以多大。

* **校验和**：16位，由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏，这个校验不仅包括TCP头部，也包括数据部分。**这是TCP实现可靠传输的一个重要保障**。校验和的计算和校验可以参照[TCP检验和 - zxin's - 博客园](https://www.cnblogs.com/zxiner/p/7203192.html)

* **紧急指针**：16位，只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。使用紧急指针是发送端向另一端发送紧急数据的一种方式。

* **选项和填充**：TCP头部的最后一个选项字段是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节。 最常见的可选字段是最长报文大小MSS，每个连接方通常都在通信的第一个报文段中指明这个选项，它表示本端所能接受的最大报文段的长度。

* **数据部分**：TCP 报文段中的数据部分是可选的。在连接建立或者终止时，双方交换的报文段仅有 TCP 首部；如果一方没有数据要发送，也会使用没有任何数据的首部来确认收到的数据；在处理超时的许多情况中，也会发送不带任何数据的报文段。

## 2.2 TCP建立链接的流程

![](http://123.57.190.49:12121/api/image/6F444820.png)

### 2.2.1 基本流程

<img src="http://123.57.190.49:12121/api/image/N006PXL6.jpg" title="" alt="" data-align="center">

**第一次握手**

由客户端发起，客户端初始化一个随机的seq x，随后，发送一个SYN标志位为1的数据包发送给接收服务器，进入SYN-SENT阶段。

**第二次握手**

服务器接收到这个包后，初始化一个随机的seq y，确认号为x+1(所以SYN报文占据了一个序号)，标志位SYN和ACK均为1，发送给客户端，进入SYN-RCVD阶段，同时服务器会为本次链接分配资源。

**第三次握手**

客户端收到服务器的回应后，发送seq=x+1，ack为y+1(所以第二次握手也占用一个序列号)，标志位ACK为1，SYN为0，同时该报文可以携带数据，如果不携带数据，该报文并不占序列号，即服务器发送的下一个报文，ack仍为y+1，客户端进入ESTABLISHED阶段。服务器接收到报文后也进入ESTABLISHED阶段。

### 2.2.2 相关问题

**为什么需要三次握手？**

只有三次握手才能证明服务端和客户端的收发能力都是正常的。

第一次握手：客户端发数据服务端接收，服务端可以知道客户端发消息的能力是正常的，自己接收消息的能力是正常的。

第二次握手：服务端发消息客户端收，客户端可以知道自己发送接收消息的能力和服务端发送接收消息的能力是正常的。

第三次握手：客户端再发送消息服务端接收，服务端可以知道自己发送消息的能力是正常的，客户端接收消息的能力是正常的。

由此经过三次握手之后双方就可以都知道自己的发送和接收消息的能力是正常的。

**三次握手丢失会发生后什么？**

在TCP通信连接的过程中，ACK报文发生了丢包是不会重传的，ACK 丢失是由对方重传对应的报文。

**第一次丢失**：客户端发送的SYN报文会收不到服务端的响应，从而会触发超时重传，重传的SYN报文序列号和之前相同，重传最大重传次数由内核参数控制，一般是5。如果超过最大次数客户端仍没有收到回复就会断开连接。

**第二次丢失**：服务端在收到客户端的报文之后会回复SYN+ACK报文，如果第二次握手丢失了客户端会认为自己丢包了，触发超时重传，重新发送SYN报文，服务端因为收不到确认的ACK自身也会重传。

**第三次丢失**：客户端收到服务端的 SYN-ACK 报文后会给服务端回一个 ACK 报文，此时客户端状态进入到 **ESTABLISH** 状态。如果发生了丢包，服务端收不到ACK会触发超时重传机制，重传 SYN-ACK 报文，直到收到确认ACK或者达到最大重传次数。

**为什么不能是两次握手，第三次握手的作用？**

首要原因是为了防止旧的重复连接初始化造成混乱。

如果使用的是两次握手建立连接，可能客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。之前滞留的那一次请求连接，因为网络通畅了，到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

同步双方的序列号

为了实现可靠数据传输，TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。

## 2.3 TCP释放链接的流程

### 2.3.1 流程

<img src="http://123.57.190.49:12121/api/image/46P6DVNT.jpg" title="" alt="" data-align="center">

客户端和服务器均可以关闭链接。以客户端发起关闭链接为例。

**第一次挥手**

客户端发出带有FIN标志的包，此时seq为u。注意根据TCP的标准，FIN包可以携带数据，但是大多数情况，FIN包不携带数据。此时客户端进入FIN-WAIT-1的状态。

**第二次挥手**

服务器收到FIN包后，发出带ACK标志，seq=v，ack=u+1（说明FIN也占一个序列号），然后进入CLOSE-WAIT状态。客户端收到服务器的ACK包后，进入FIN-WAIT-2阶段，等待服务器的FIN包。

**第三次挥手**

服务器发送完自己需要的数据后，发送带有FIN标志的包，此时seq为w，ack为u+1，然后进入LAST-ACK阶段。

**第四次挥手**

客户端收到服务器的FIN包后，发送ack=w+1，seq=u+1的报文，进入TIME-WAIT阶段；服务器收到响应后CLOSED。客户端等待2MSL后进入CLOSED阶段

### 2.3.2 相关问题



## 2.4 TCP的流量控制

## 2.5 TCP的拥塞控制

# 3. UDP协议
