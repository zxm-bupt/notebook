# 1. 计算机的存储器结构

<img title="" src="http://123.57.190.49:12121/api/image/NR24PHRF.jpg" alt="" data-align="center">

计算机的存储结构如图所示，其中寄存器、缓存和主存都是RAM，而磁盘则是额外的存储设备(不是ROM 起码HDD不是，SSD确实是ROM)。

整个是一个三角形，由上到下，速度越来越慢，容量越来越大。这个三角形的根本原因是，价格、容量、速度的不可能三角。

如果硬盘SSD可以和RAM一样快，那没有人会去买内存。不对呀，便宜、速度快、容量大的内存，卧槽，傲腾。

# 2. OS的内存管理功能

OS在内存上的主要功能是：

1. 内存的分配与回收

2. 内存空间的扩充

3. 地址的转换

4. 存储保护

# 3. 内存分配与回收

## 3.1 概述

> 当作业或进程创建后系统会为他们分配内存空间，当结束后内存空间也会被回收。

## 3.2 分配方式

### 3.2.1 连续分配方式

#### 3.2.1.1 单一连续分配

> 将内存空间分配给某个单一的进程

该方案显然容易实现，且没有外部碎片(废话全分给一个人了)，但是该方案容易导致内部碎片。

#### 3.2.1.2 固定分区分配

> 将用户空间划分成若干大小的分区，每个分区装入一个程序，有固定大小和非固定两种

该方案减少了内部碎片，而且没有外部碎片，但是对于占用大内存的程序，可能一个分区无法承载er

#### 3.2.1.3 动态分区分配

> 进程装入内存时，根据内存的需要划分分区，使得分区大小与内存需要大小相同

该方案没有内部碎片，但是会产生外部碎片。因此需要有外部碎片的清理办法，而且多个分区合适时，选择哪个分区也是一个问题。

常见的分配算法：

* [首次适应算法](https://zhida.zhihu.com/search?content_id=119598958&content_type=Article&match_order=1&q=%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95&zhida_source=entity)：进程进入内存之后从头开始查找第一个适合自己大小的分区。空间分区就是按照地址递增的顺序排列。算法开销小，回收后放到原位置就好。综合看这个算法性能最好。
* [最佳适应算法](https://zhida.zhihu.com/search?content_id=119598958&content_type=Article&match_order=1&q=%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95&zhida_source=entity)：将分区从从小到大排列(容量递增)，找到最适合自己的分区，这样会有更大的分区被保留下来，满足别的进程需要。但是算法开销大，每次进程消亡产生新的区域后要重新排序。并且当使用多次后会产生很多外部碎片。
* [最坏适应算法](https://zhida.zhihu.com/search?content_id=119598958&content_type=Article&match_order=1&q=%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95&zhida_source=entity)：将分区从从大到小排列(容量递减)，进程每次都找最大的区域来使用。可以减少难以利用的外部碎片。但是大分区很快就被用完了，大的进程可能会有饥饿的现象。算法开销也比较大。
* [邻近适应算法](https://zhida.zhihu.com/search?content_id=119598958&content_type=Article&match_order=1&q=%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95&zhida_source=entity)：空间分区按照地址递增的顺序进行排列，是由首次适应演变而来，进程每次寻找空间，从上一次查找的地址以后开始查找(不同于首次适应，首次适应每次从开头查找)。算法开销小，大的分区也会很快被用完。

### 3.2.2 非连续分配

#### 3.2.2.1 页式管理

> 把主存空间划分为大小相等的块，块相对较小，作为主存的基本单元。每个进程也以块为单位划分，进程执行时，以块为单位申请内存空间
> 
> 相关概念：
> 
> * 块：外存中的块
> * 页(页面)：进程里面的块
> * 页框(页帧)：内存中的块
> * 地址结构：地址结构包含两部分，第一部分是页号(P)，根据页号的位数可以算出地址结构可容纳最大页数；第二部分是页内偏移量(W)，可以计算出页面的大小。地址结构决定了虚拟内存。
> * 页表：为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录每个页面(进程中的块)在内存中的物理块号，一般放在内存中。页表项由两部分构成，第一部分存储页号，第二部分储存物理内存中的块号。
> * 注意：进程中的块的各个代码，在内存中对应的物理地址是=页表中物理内存块号+地址结构中页内偏移量

![](http://123.57.190.49:12121/api/image/026BDPXR.jpg)

* 1、在系统中会设置一个页表寄存器(PTR)，用来储存页表在内存中的起始地址Ｆ和页表长度M
* 2、根据逻辑地址计算出页号和业内偏移量
* 3、判断页号是否越界
* 4、查询页表找到页号对应的页表项，确定页面的内存块号(第一次访存，因为页表在内存中)
* 5、用内存块号和业内偏移量的到物理地址
* 6、访问内存目标单元(第二次访存)

问题：

(1)每次访问内存都需要地址转换(逻辑地址->物理地址)，浪费时间；

(2) 内存中页表不能占有太大的内存，不然降低了内存利用率。同时因为页表需要了连续的内存，当页面很多时，页表过大可能放不进内存

为了解决每次都要访存的问题，增加了一个特殊的硬件TLB，TLB是一种相连存储器。其读取速度比内存要快的多，因此可以将一部分页表内容防护如TLB来加速转换。

![](http://123.57.190.49:12121/api/image/240H2HVD.jpg)

步骤：

* 1、CPU给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将次页号与快表中的页号做比较

* 2、如果找到，直接从快表去除该页对应的页框号，与地址结构的地址偏移量计算出物理地址访存

* 3、如果没有找到，再去慢表中找，然后如上访存，之后将这个页表项加入到快表中。注意有的系统为了节省时间，会在快表中找与在慢表中找同时进行，这样可以节约系统时间。

为了解决第二个问题，引出了多级列表。

步骤：

* 按照地址结构将逻辑地址拆分成三部分(一级页号、二级页号、页内偏移量)

* 从PCB中读取页目录表起始地址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置

* 根据二级也好查表，找到最想访问的内存块号

* 结合页内偏移量得到物理地址

#### 3.2.2.2 段式管理

> 分页存储是从计算机的角度设计的，目的是为了提高内存的利用率，提升计算机的性能。分段存储的提出是考虑到程序员和用户，以满足方编程、数据共享、信息保护、动态增长、动态链接的需要。
> 
> * 分段：按照进程自然划分炒年成逻辑空间，例如进程由主程序、两个子程序、栈和数据组成。于是可以把这个进程分成5段，每一段的逻辑地址从0开始编址，并分配一段连续的内存空间。(注意这里段内必须连续，段与段之间可以分散)
> * 逻辑地址结构：是由两部分组成第一部分为段号S，看进程是哪一个段，段号的位数决定了进程分了多少段；第二部分为段内偏移量W，段内偏移量决定了这段进程的最大长度。
> * 段表：每个进程都以一张逻辑空间与内存空间映射的段表，每个段表对应进程的一段，段表项季度该段在内存中的起始地址和长度。段表由三个部分组成：段号、段长、本段在主存中的起始地址(基址)。



![](http://123.57.190.49:12121/api/image/0222T4PB.jpg)

步骤：

* 进切换内核程序回复进程的运行环境，从PCB中找到段表寄存器
* 根据逻辑地址得到段号、段内地址
* 将段号与段表长度比较，判断段号是否越界，产生越界中断
* 查询段表，找到对应的段表项，段表项存放的地址为段表起始地址+段号*段表项长度(因为为了节省内存空间，可以参略段表中的段号，那么计算段表项的起始地址就可以用这种方法)
* 对段内地址W进行检查，是否超过段长。如果超越就产生中断
* 根据段的基址和和段内地址得到物理地址
* 访问目标内存单元

**段式和页式的区别：**

1、页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存的利用率。分页仅仅是系统管理上的需求，安全是系统行为对用户是不可见的 段是信息的逻辑单位，分段的主要目的是更好地满足用户需求，一个段通常包含一组数语一个逻辑板块的信息。分段是用户可见的，用户编程时需要显示的给出段名。

2、页的大小是固定的，系统绝决定；段的大小是不固定的，取决于系统程序

3、分页的用户地址空间是一维的，程序员只需要给出一个记忆符就可以表示一个地址 分段存储管理的地址空间是二维的，程序员需要在标识一个地址的时候，既要给出段名，也要给出段内地址

4、分段比分页更容易实现信息的共享和保护 注意：不能修改的代码称为纯代码(可重入代码)，这样的代码段不是临界资源，可以共享。可修改的代码是不可以共享的（比如由很多变量的代码段） 比如：生产者进程的一个进程段，是用来判断该缓冲区此时是否可以访问，这个时候消费者进程的段表项也可以指向这里 为什么分业管理不方便实现代码共享？ 因为将生产者进程分段，由于页面的空间有限，一段可能被装入多个空间，一个空间也可能有多个代码段被装进来，所以适合共享，达不到安全的效果

5、分页：内存空间利用率高，不会产生外部碎片，只有少量的内部碎片；不方便按照逻辑模块实现信息的共享与保护 分段：方便按照逻辑模块实现信息的共享与保护；如果段太长，为其分配很大的存储空间很不方便，容易产生外部碎片（这个虽然可以用前面的一些紧凑技术解决一部分，但是时间代价很大）

#### 3.2.2.3 段页式管理

> 背景：由于分段与分页各有利弊，页式存储提高内存利用率，段式存储反应程序逻辑结构有利于共享数据，所以可以结合二者来组成新的内存管理方式。
> 
> 概念：首先将进程根据逻辑结构划分成若干个逻辑段，每个段都有自己的段号，然后将这些段划分成若干个大小固定的页。这样对内存空间的管理依然和分页式管理相似，将内存分成和页面大小相同的存储块，对内存分配一存储块为单位。
> 
> 逻辑地址结构：逻辑地址结构由段号S(决定每个进程的段数)、页号P(决定每段的页数)、页内偏移量W(页面的大小和内存块的大小)组成。

<img src="http://123.57.190.49:12121/api/image/TZ602PJX.jpg" title="" alt="" data-align="center">

步骤：

* 根据逻辑地址得到段号、页号、页内偏移量
* 将段号S与段表长度比较，判断段号是否越界
* 查询段表，找到对应的段表项，段表项存放的地址为段表起始地址+段号*段表项长度(因为为了节省内存空间，可以参略段表中的段号，那么计算段表项的起始地址就可以用这种方法)(第一次访存)
* 将页号与页表长度比较，检查页号是否越界
* 根据页表存放块号、页号查询页表，找到对应的页表项(第二次访存)
* 根据内存块号、页内偏移量得到最终的物理地址
* 访问目标内存单元(第三次访存)
* 注意：1、段表寄存器和页表寄存器作用有两个，一是在段表或页表中寻址，二是判断是否越界；2、在一个进程中段表只能有一个，页表可以有很多个。3、分段是可见的，分页是不可见的所以段页式管理结构是二维的。4、这里也可以引入快表机构，用段号和页号作为查询快表的关键字，如果快表命中就只需要访存一次。

# 4. 内存空间的扩充



# 5. 地址的转换

# 6. 存储保护

# 



<img src="http://123.57.190.49:12121/api/image/DR4HN8RH.jpg" title="" alt="" data-align="center">

# 参考

[Cache直接映射、组相连映射以及全相连映射（转载） - east1203 - 博客园](https://www.cnblogs.com/east1203/p/11572500.html)
