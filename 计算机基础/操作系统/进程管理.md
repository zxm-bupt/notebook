# 1. 进程的基本概念

## 1.1 概念

> 进程是操作系统进行资源分配和调度的基本单位，是一个独立运行的程序实体。每个进程拥有独立的内存空间、文件描述符、寄存器状态等资源。进程之间的资源是相互隔离的，因此进程间通信需要通过操作系统提供的特定机制（如管道、消息队列、共享内存等）进行。由于进程拥有独立的资源，所以进程间的切换和调度开销较大。进程是操作系统进行资源分配和调度的基本单位，是一个独立运行的程序实体。每个进程拥有独立的内存空间、文件描述符、寄存器状态等资源。进程之间的资源是相互隔离的，因此进程间通信需要通过操作系统提供的特定机制（如管道、消息队列、共享内存等）进行。由于进程拥有独立的资源，所以进程间的切换和调度开销较大。

进程是操作系统进行资源分配的基本单位，调度的基本单位在线程出现后，调度的基本单位被线程抢走。进程是操作系统最终的概念，没有进程，就没有OS。

## 1.2 PID与PCB

PID（Process Identification）[操作系统](http://baike.baidu.com/view/880.htm)里指进程识别号，也就是进程标识符。[操作系统](http://baike.baidu.com/view/880.htm)里每打开一个[程序](http://baike.baidu.com/view/17674.htm)都会创建一个进程ID，即PID。

只要运行一程序，系统会自动分配一个标识。 进程中止后，这个号码就会被回收，并可能被分配给另一个新进程。  

如果成功运行一个程序，然后再运行别的程序时，系统会自动分配另一个PID。

进程控制块(PCB)（系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程。系统利用PCB来控和管理进程，所以PCB是系统感知进程存在的唯一标志。进程与PCB是一一对应的）在不同的操作系统中对进程的控制和管理机制不同，PCB中的信息多少不一样，通常PCB应包含如下一些信息。

1. 进程标识符 PID：每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。

2. 进程当前状态 status：说明进程当前所处的状态。为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列\，如等待打印机队列、等待磁盘I/O完成队列等等。

3. 进程相应的程序和数据地址，以便把PCB与其程序和数据联系起来。

4. 进程资源清单。列出所拥有的除CPU外的资源记录，如拥有的I/O设备)，打开的文件列表等。

5. 进程优先级 priority：进程的优先级反映进程的紧迫程度，通常由用户指定和系统设置。

6. CPU现场保护区 cpustatus：当进程因某种原因不能继续占用CPU时（如等待打印机），释放CPU，这时就要将CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。

7. 进程同步与通信机制 用于实现进程间互斥、同步和通信所需的信号量等。

8. 进程所在队列PCB的链接字 根据进程所处的现行状态，进程相的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。

9. 与进程有关的其他信息。 如进程记账信息，进程占用CPU的时间等。

## 1.3 进程的状态

![进程的状态变化](http://123.57.190.49:12121/api/image/820PJDZV.jpg)

新建:当一个进程刚刚被创建时，它处于新建状态。在这个状态下，操作系统为进程分配必要的资源，如内存、文件描述符等，并初始化进程控制块（PCB）等数据结构。这个状态下进程开始初始化，类似于一个人出生的过程，现在他还处于从娘胎里出来的阶段。

就绪Ready：进程已经准备好运行，正在等待操作系统调度器分配CPU时间片。就绪状态的进程已分配到了除CPU之外的所有必要资源，**只需要CPU时间片**就可以开始执行。

运行Running：进程正在CPU上执行。在任何给定时刻，每个CPU或核心上最多只能有一个进程处于运行状态。

阻塞Blocked：进程因等待某个事件（如I/O操作完成、锁释放或信号到达）而暂停执行。在阻塞状态下，进程无法继续执行，直到等待的事件发生。

终止Terminated：进程已经完成执行或因某种原因被终止。在终止状态下，进程的资源被回收，进程控制块（PCB）可能被保留一段时间以便父进程获取子进程的退出状态。

以上是一个基本概念，不如我们去看一下Linux下进程有哪些状态吧。为什么不用windows，因为他告诉你此进程处于效率模式，你会一脸懵逼，什么是效率模式。

![](http://123.57.190.49:12121/api/image/26LZD464.png)

如图所示，其中STAT为进程的状态。

* **`R` (Running or Runnable)**
  
  * **含义**: 进程正在运行（占用 CPU）或者已经准备就绪，在运行队列中等待被调度执行。
  * **进入原因**: 进程被创建后、从睡眠或停止状态被唤醒后，或者在等待 CPU 时间片时，会进入此状态。对应Ready和Running状态

* **`S` (Interruptible Sleep)**
  
  * **含义**: 进程正在等待某个事件的发生（例如等待 I/O 操作完成、等待信号量、等待网络连接、`sleep()` 调用等）。这种状态的进程可以被信号中断。这是进程最常见的状态之一。
  * **进入原因**: 进程执行了会导致阻塞的系统调用（如 `read()`, `write()`, `select()`, `sleep()`, `wait()`, `pause()` 等），需要等待资源或事件才能继续执行。对应Block状态。

* **`D` (Uninterruptible Sleep)**
  
  * **含义**: 进程通常在等待不可中断的 I/O 操作（通常是磁盘 I/O）。它不能被信号中断，即使是 `SIGKILL` 也不行（直到 I/O 完成）。这种状态是为了防止进程在与硬件交互的关键阶段被中断而导致数据损坏或设备状态不一致。
  * **进入原因**: 进程正在执行一个**不能被中断**的内核代码路径，通常是直接与硬件交互，如等待磁盘读写完成、NFS 操作等。如果进程长时间处于 `D` 状态，通常表示底层硬件或驱动程序存在问题。

* **`T` (Stopped or Traced)**
  
  * **含义**: 进程被暂停执行。
  * **进入原因**:
    * 接收到 `SIGSTOP`, `SIGTSTP` (例如在终端按 `Ctrl+Z`), `SIGTTIN`, `SIGTTOU` 等信号。
    * 进程正在被调试器（如 `gdb`）跟踪 (Traced)。
  * 进程可以通过接收 `SIGCONT` 信号恢复到 `R` 状态。

* **`Z` (Zombie)**
  
  * **含义**: 进程已经终止执行（调用了 `exit()` 或异常终止），但其父进程尚未读取其退出状态（通过 `wait()` 或 `waitpid()` 系统调用）。进程描述符（Process Descriptor）仍然保留在内核中，以便父进程查询其退出原因。
  * **进入原因**: 进程执行完毕或被终止，内核需要通知其父进程并传递退出码。在父进程调用 `wait()` 系列函数之前，子进程就处于僵尸状态。它本身不占用内存和 CPU，只占用内核进程表中的一个条目。大量的僵尸进程通常意味着父进程有 Bug（没有正确处理子进程退出）。

* **`X` (Dead)**
  
  * **含义**: 这是一个很少见的状态，表示进程已经死亡。理论上在 `ps` 的输出中不应该看到这个状态。

**状态修饰符 (通常附加在主状态码之后):**

* `s`: 表示该进程是一个会话领导者 (Session Leader)。
* `+`: 表示该进程位于前台进程组。
* `l`: 表示进程是多线程的 (使用了 `CLONE_THREAD`，内核视角看是轻量级进程 LWP)。
* `N`: 表示进程优先级较低 (niced)。
* `<`: 表示进程优先级较高 (实时进程或未被 nice 降低优先级)。

## 1.4 进程的通信方式

进程间通信（Inter-Process Communication, IPC）是指进程之间通过特定的方式共享数据和信息的过程。在多任务操作系统中进程间通信对于协调进程的执行和实现资源共享非常重要。以下是一些常见的进程间通信方式：进程间通信（Inter-Process Communication, IPC）是指进程之间通过特定的方式共享数据和信息的过程。在多任务操作系统中进程间通信对于协调进程的执行和实现资源共享非常重要。以下是一些常见的进程间通信方式：

**管道**

* 管道是一种单向的IPC，内核中存在一定缓冲区，并且传输的数据是字节流。管道在UNIX中是被当做一个文件，系统调用会提供两个文件描述符供用户读写文件。
* 如果管道的写端没有被进程持有，而收端尝试去读的话，此时会受到EOF，如果写端有进程持有的话，读端就会阻塞在read上。
* 管道分为**命名管道与匿名管道**，匿名管道没有名字，是通过系统调用pipe()创建的,只返回两个文件描述符，注意是pipe[1]写给pipe[0]。因为匿名管道没有名字，所以一般匿名管道只能用于两个关系比较近的进程，比如fork出来的父子进程。
* 当两个关系比较远的时候，此时就应该使用命名管道，创建该管道的命令为mkfifo，需要指定一个全局的文件名与权限，之后读写管道就是在读写这个文件。
* 管道只能单项传输数据，如果想双向传输，那么就用socketpair。socketpair会创建两个socket，父进程关闭一个，子进程关掉另一个。这样双方各拿一个socket通信。

**消息队列**

* 消息队列，是唯一一个以消息为数据抽象的通信方式，消息队列在内核中的数据结构是一个单链表构成的队列，最初会有个消息头部指针，保存着消息队首与相应的权限；每个消息都会有下一个消息的指针，以及消息本身的内容。
* 消息队列的内存空间有限，一般来说传递长消息时采用共享内存的方式，而非消息队列。通过消息队列传递数据需要先copy到内核，然后再到收端，所以有个代价。

**共享内存**

* 使用共享内存很重要的一个原因是共享内存不需要先拷贝到内核空间中，**速度比较快**，共享内存的核心思路就是允许一个或者多个进程所在的虚拟地址空间中映射相同的物理页，从而进行通信。

* 共享内存的实现机制：首先内核会给全局的共享内存维护一个全局的队列结构，这个队列的每一项是一个shmid_kernel结构体与一个IPC key来绑定的，各进程可以通过key来找到并使用同一段共享内存；该进程能否操作这段共享内存时SystemV的权限检查机制来判断；

* 当两个进程同时对一个共享内存建立了映射后，内核会给他们分配两个VMA结构体，进程可以通过他们各自的虚拟地址来访问VMA并访问其背后的共享内存空间。
  ![](http://123.57.190.49:12121/api/image/TRTL04R2.png)

**信号**

* 管道、消息队列、共享内存主要是关注数据传输设计，而信号的作用是**单项的事件通知**能力。一个进程会为一些特定的信号注册回调函数，当进程收到对应的信号后，内核会自动调用该信号的回调函数。
* 信号的发送者可以是其他用户态的进程，但更多的是内核发送通知，用户态一般是使用操作系统提供的API来通知其他进程，如kill等；信号的阻塞提供一个专门的系统调用sigpromask来设置相应的信号掩码。
* 信号需要用sigaction来注册信号，注册的格式是一个sigaction的结构体，结构体包含相应的信号掩码以及回调函数。
* 信号需要考虑其可重入性，比如一个进程收到了一个信号后回调函数由于中断等原因下陷到内核时，又收到了一个相同的信号，这时候可能会重新调用一次该回调函数，因此这种情况下必须保证其可重入性。可重入一般要注意，不使用静态数据，或者静态数据只读；尽量使用本地数据，在使用全局数据时记得加锁；不调用不可重入的函数。
* 好吧，这堆东西看起来很没有意思，现在让我们看一下，linux下支持哪些信号可以使用

---

在终端里，我们会使用`cltr+c`来终止程序。通常会向当前在前台运行的进程（或更准确地说，是前台进程组中的所有进程）发送 `SIGINT` 信号。

好把，这又多出了一堆东西，但在我们搞明白什么是SIGINT什么是前台进程组之前。我们先明白，信号的发送者和接收者。

**信号的发送者**是严格来说，是**内核中的终端驱动程序 (TTY driver)**。它监测到与终端关联的键盘输入 `Ctrl+C`（这是终端的 `intr` 特殊字符，通常默认是 `Ctrl+C`），然后由它负责生成 `SIGINT` 信号。所以，信号的“源头”可以理解为与终端交互的内核部分，它代表了用户的意图。

**接收方**: 当前终端的“前台进程组” (Foreground Process Group) 中的所有进程。前台进程组其实就是前台运行的程序，可能会有疑问，前台不是只能运行一个程序吗。并不是的，例如 `ps aux |  grep ssh`实际上启动了两个程序ps和grep，当然你会说，这两个程序是一先一后运行的，但是如果是`yes | head -n 5`呢，yes是一个一直运行的程序，然后head会因为yes也不听的运行。如果按下cltr + c应该是两个进程都收到SIGINT。

现在让我们回到信号上来。

`SIGINT` 是众多预定义信号中的一种。Linux/Unix 系统定义了大约 31 种标准信号（以及一些实时信号），例如：

* `SIGTERM`: 请求进程终止（比 `SIGKILL` 更礼貌，允许进程清理）。

* `SIGKILL`: 强制终止进程（不能被捕获或忽略）。

* `SIGHUP`: 挂起信号，常用于通知守护进程重新加载配置。

* `SIGUSR1`, `SIGUSR2`: 用户自定义信号，可用于进程间特定的通信目的。

如果这时候你愿意动动脑 ，你就会想到，我在写代码时从来没想过写相关信号的处理逻辑，那我的程序是如何处理这些信号的。那么我们就要提到一个东西了，操作系统。

> 进程同步与通信机制 用于实现进程间互斥、同步和通信所需的信号量等。

我们在上文提到PCB会存储进程通信的相关数据，进程收到信号后的回调函数(我很不喜欢这个名字，让人摸不着头脑)就注册在PCB中。在这个场景中，如果不在程序显式定义接收到SIGINT信号后的触发函数(我喜欢这个表述)，那么会操作系统会为其填上默认的操作，即中断进程。

---

# 2. 线程的基本概念



# 3. 进程的调度



# 4. 同步与异步



# 5. 死锁
