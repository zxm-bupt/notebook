# 1. 垃圾回收

## 1.1 基本概念

为什么需要GC，GC的作用就是减少写代码时的心智负担。当然可以没有GC，但是需要程序员自己处理内存的分配和回收。GC实际上干两件事，找到垃圾，清理垃圾。

> 内存其实就是一块连续的空间，可以看做一个大数组，这块空间在业务运行时，经常会或零散或整齐的分布一些大大小小的对象，怎么样高效的分配和回收这块空间，同时尽量不影响业务系统的运行，就是GC垃圾回收要做的事，学习了七种基本的GC算法之后，我们更加知道，工程技术中没有“银弹”，没有完美无缺的算法，只有最适合自己业务系统的解法。

首先，在回收之前，我们先确定，在内存里，我们的对象(我不想用这个词，但是我想不到好的词了，可能后面会换成别的词)是什么样子的。为了方便理解，我们将对象做这样的描述，对象由头(header)和域(field)构成。对象的头，主要包含对象的大小、种类信息。对象中可访问的部分称为“域”，可以认为是 GO语言中结构体的变量。

<img src="http://123.57.190.49:12121/api/image/0XX8VR6Z.png" title="" alt="" data-align="center">

指针是指向内存空间中某块区域的值。GC 是根据对象的指针指向去搜寻其他对象的。

<img src="http://123.57.190.49:12121/api/image/BNFH88V8.png" title="" alt="" data-align="center">

我们将内存空间中被其他对象通过指针引用的对象成为活动对象，没有对象引用的对象是非活动对象，也就是GC需要回收的垃圾。如图2.3所示。

根(root)是“根基”“根底”。在 GC 的世界里，根是指向对象的指针的“起点” 部分。堆指的是用于动态(也就是执行程序时)存放对象的内存空间。当应用程序申请存放对象时， 所需的内存空间就会从这个堆中被分配给 应用程序。

<img src="http://123.57.190.49:12121/api/image/D44N0RNV.png" title="" alt="" data-align="center">

## 1.2 GC算法性能的评价标准

评价 GC 算法的性能时，我们采用以下 4 个标准。

* 吞吐量 
* 最大暂停时间 
* 堆使用效率 
* 访问的局部性

**吞吐量：** GC的吞吐量是：运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。

GC的吞吐量就是应用程序执行的时间(不是内存大小哦)和GC时间的比值，GC执行的总时间越短，GC吞吐量越大。

> 人们通常都喜欢吞吐量高的 GC 算法。然而判断各算法吞吐量的好坏时不能一概而论。因为工程技术中，任何好处都是有代价的。

**最大暂停时间：** 本文介绍的所有GC算法，都会在GC执行过程中使应用程序暂停执行。最大暂停时间指的是“因执行GC而暂停执行应用程序的最长时间”。

**堆使用的效率：** 程序在运行过程中，单位时间内能使用的堆内存空间的大小。

**访问的局部性：** 部分GC算法会利用这种局部性原理，把具有引用关系的对象安排在堆中较近的位置，就能提高在缓存Cache中读取到想要的数据的概率，令应用程序高速运行。

## 1.3 常见的GC算法

三种最基本的GC算法是标记-清除法、引用计数法、GC复制算法。后面延伸出来的4种不过是三种基本算法的组合而已。

# 2.  GC标记-清除算法

## 2.1 基础概念

GC标记-清楚算法，分两个阶段来干找到垃圾和清理垃圾两件事。标记阶段用来找到垃圾，而清除阶段用来清理垃圾。

### 2.1.1 标记阶段

在标记阶段中，垃圾回收器Collector 会为堆里的所有活动对象打上标记。为此，我们首先要标记通过根直接引用的对象。首先我们标记这样的对象，然后递归地标记通过指针数组能访问到的对象。 这样就能把所有活动对象都标记上了。

标记Mark对象，是在对象的头部进行置位操作。如下所示，是程序标记对象的动作示意。

<img src="http://123.57.190.49:12121/api/image/2Z8T4T04.png" title="" alt="" data-align="center">

标记完所有活动对象后，标记阶段就结束了。标记阶段结束时的堆如下所示，从根对象沿着指针引用找下去，会发现有四个对象被引用，都需要打上标记位。

<img src="http://123.57.190.49:12121/api/image/0P482882.png" title="" alt="" data-align="center">

用一句话概括，标记阶段就是“遍历对象并标记”的处理过程。

### 2.1.2 清除阶段

在清除阶段中，垃圾回收器Collector 会遍历整个堆，回收没有打上标记的对象(即垃圾)，使其能再次得到利用。

在清除阶段，GC程序会遍历堆，具体来说就是从堆首地址开始，按顺序一个个遍历对象的标志位。如果一个对象设置了标记位，就说明这个对象是活动对象，必然是不能被回收的。

GC程序会把非活动对象回收再利用。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表。在之后进行分配时只要遍历这个空闲链表，就可以找到分块了。

<img src="http://123.57.190.49:12121/api/image/XPV06844.png" title="" alt="" data-align="center">

在清除阶段，程序会遍历所有堆，进行垃圾回收。也就是说，所花费时间与堆大小成正 比。堆越大，清除阶段所花费的时间就会越长。

在GC的标记-清除过程中，还会不断进行的两个动态操作那就是分配和合并。

分配是指将回收的垃圾进行再利用。GC程序在清除阶段已经把垃圾对象连接到空闲链表了。当应用程序创建新对象时，搜索空闲链表并寻找大小合适的分块，这项操作就叫作分配。

根据分配策略的不同可能会产生大量的小分块。但如果它们是连续的， 我们就能把所有的小分块连在一起形成一个大分块。这种“连接连续分块”的操作就叫作合并(coalescing)，合并是在清除阶段进行的。

## 2.2 优缺点

**优点：**

1. 实现简单，很容易在基本的GC标记清除法基础上改进，或者容易和其他算法组合形成新的GC算法。

2. GC 标记-清除算法因为不会移动对象，所以非常适合搭配保守式 GC 算法。

**缺点：**

1.  碎片化。使用过程中会逐渐产生被细化的分块，不久后就会导致无数的小分块散布在堆的各处。

2. 分配速度慢。GC 标记-清除算法中分块不是连续的，因此每次分配都必须遍历空闲链表，找到足够大的分块才行。

3. 与写时复制技术(copy-on-write)不兼容。

## 2.3 改进方案

# 3. 引用技术法

## 3.1 基础概念

引用计数法(Reference Counting)就是，让所有对象事先记录下“有多少程序引用自己”。形象点儿说，就是让各对象知道自己的“人气指数”，让没有人气的对象自己消失。

引用计数法依靠“计数器”记录有多少对象引用了自己(被引用数)。

<img src="http://123.57.190.49:12121/api/image/L8V0044L.png" title="" alt="" data-align="center">

如图所示，是A的指针由指向B改为指向C时，各对象的计数器的变化情况。初始状态下从根引用 A 和 C，从 A 引用 B。A 持有唯一指向 B 的指针，假设现在将该指针更新到了 C，B 的计数器值变成了 0，计数器变更时，计数器为0的对象会被回收，因此 B 被回收了。且 B 连接上了空闲链表， 能够再被利用了。又因为新形成了由 A 指向 C 的指针，所以 C 的计数器的值增量为 2。

<img src="http://123.57.190.49:12121/api/image/R4X6J6ZD.png" title="" alt="" data-align="center">

## 3.2 优缺点

**优点：**

1. 可即刻回收垃圾。在引用计数法中，每个对象始终都知道自己的被引用数(就是计数器的值)。当被引用数的值为 0 时，对象马上就会把自己作为空闲空间被GC程序连接到空闲链表。也就是说，各个对象在变成垃圾的同时就会立刻被回收。另一方面，在其他的 GC 算法中，即使对象变成了垃圾，程序也无法立刻判别。只有当内存分块用尽后 GC 开始执行时，才能知道哪个对象是垃圾，哪个对象不是垃圾。

2. 最大暂停时间短。在引用计数法中，只有当应用程序更新指针时(计数器变更)程序才会执行垃圾回收。也就是说， 每次生成垃圾时这部分垃圾都会被回收，因而大幅度地削减了GC的最大暂停时间。

3. 没有必要沿着指针查找被引用对象。引用计数法和 GC 标记-清除算法不一样，没必要由根沿着指针查找。当我们想减少沿着指针查找的次数时，它就派上用场了。打个比方，在分布式环境中，如果要沿各个计算节点之间的指针进行查找，成本就会增大。

**缺点：**

1. 计数器值的增减处理繁重。在程序繁忙的情况下，指针都会频繁地更新。特别是有根的指针，会以极快的速度进行更新。在引用计数法中，每当指针更新时，计数器的值都会随之更新，因此值的增减处理必然会变得繁重。

2. 计数器需要占用很多位。用于引用计数的计数器最大必须能数完堆中所有对象的引用数。打个比方，假如我们用的是 32 位机器，那么就有可能要让 2 的 32 次方个对象同时引用一个对象。考虑到这种情况， 就有必要确保各对象的计数器有 32 位大小。也就是说，对于所有对象，必须留有 32 位的空间。这就害得内存空间的使用效率大大降低了。

3. 实现烦琐复杂。该算法本身很简单，但事实上实现起来却不容易。 进行指针更新操作时，需要同时变更对象引用和计数器，这容易导致遗漏，一旦遗漏了某处，内存管理就无法正确 进行，就会产生 BUG。实现烦琐复杂。该算法本身很简单，但事实上实现起来却不容易。 进行指针更新操作时，需要同时变更对象引用和计数器，这容易导致遗漏，一旦遗漏了某处，内存管理就无法正确 进行，就会产生 BUG。

4. 循环引用无法回收。因为两个对象互相引用，所以各对象的计数器的值都是 1。但是这些对象组并没有被其他任何对象引用。因此想一并回收这两个对象都不行，只要它们的计数器值都 是 1，就无法回收。

## 3.3 改进方案

# 4. GC复制算法

## 4.1 基础概念

GC 复制算法(Copying GC)，就是只把某个空间里的活动对象复制到其他空间，把原空间里的所有对象都回收掉。在此，我们将复制活动对象的原空间称为 From 空间，将粘贴活动对象的新空间称为 To 空间。

GC 复制算法是利用 From 空间进行分配的。当 From 空间被完全占满时，GC 会将活动对象全部复制到 To 空间。当复制完成后，该算法会把 From 空间和 To 空间互换，GC 也就结束了。From 空间和 To 空间大小必须一致。这是为了保证能把 From 空间中的所有活动对象都收纳到 To 空间里。GC 复制算法的概要如下图所示。

<img src="http://123.57.190.49:12121/api/image/H8X88Z8V.png" title="" alt="" data-align="center">

如图3.12所示，堆里From空间已经分配满了部分对象，对象间的引用关系如连线所示，即将开始GC，To空间目前没有被使用，有个空闲分块起始指针$free$需要指向$To$空间的开头，对象复制到了空间放在$free$指向的位置。

开始GC后，首先复制的是从根引用的对象B和G，对象B先被复制到To空间，空闲分块起始指针$free$移到B对象之后。 B 被复制后生成的对象称为 B'，原对象B还在From空间，B里保存了指向B’的指针，因为原From空间还有其他对象要通过B找到B’。如图3.13所示。

<img src="http://123.57.190.49:12121/api/image/PH4F8D46.png" title="" alt="" data-align="center">

目前只把 B'复制了过来，它的子对象 A 还在 From 空间里。下面要把这个 A 复制到 To 空间里。

<img src="http://123.57.190.49:12121/api/image/0H026R0D.png" title="" alt="" data-align="center">

这次才可以说在真正意义上复制了 B。因为 A 没有子对象，所以对 A 的复制也就完成了。

<img title="" src="http://123.57.190.49:12121/api/image/8VXV648J.png" alt="" data-align="center">

接下来，我们要复制和 B 一样从根引用的 G，以及其子对象 E。虽然 B 也是 G 的子对象， 不过因为已经复制完 B 了，所以只要把从 G 指向 B 的指针换到 BꞋ 上就行了。

最后只要把 From 空间和 To 空间互换，GC 就结束了。GC 结束时堆的状态如图所示。

![](http://123.57.190.49:12121/api/image/PFX420F6.png)

从GC复制算法的执行过程可以知道，从根开始搜索对象，采用的是深度优先搜索的方式。

## 4.2 优缺点

**优点：** 

1. 优秀的吞吐量。GC 标记-清除算法消耗的吞吐量是搜索活动对象(标记阶段)所花费的时间和搜索整体堆(清除阶段)所花费的时间之和。因为 GC 复制算法只搜索并复制活动对象，所以跟一般的 GC 标记-清除算法相比，它能在较短时间内完成 GC。也就是说，其吞吐量优秀。

2. 可实现内存的高速分配。GC 复制算法不使用空闲链表。这是因为分块是一个连续的内存空间。因此，调查这个分块的大小，只要这个分块大小不小于所申请的大小，那么移动空闲分块的指针就可以进行分配了。

3. 不会发生碎片化。基于算法性质，活动对象被集中安排在 From 空间的开头。像这样把对象重新集中，放在堆的一端的行为就叫作压缩。在 GC 复制算法中，每次运行 GC 时都会执行压缩。因此 GC 复制算法有个非常优秀的特点，就是不会发生碎片化。

4. 满足高速缓存的局部性原理。在 GC 复制算法中有引用关系的对象会被安排在堆里离彼此较近的位置。访问效率更高。

**缺点：**

1. 堆使用效率低下。GC 复制算法把堆二等分，通常只能利用其中的一半来安排对象。也就是说，只有一半 堆能被使用。相比其他能使用整个堆的 GC 算法而言，可以说这是 GC 复制算法的一个重大的缺陷。

2. 不兼容保守式 GC 算法。因为GC复制算法会移动对象到另外的位置，保守式GC算法要求对象的位置不能移动，这在某些情况下有一点的优势。而GC复制算法没有这种优势。

3. 递归调用函数。复制某个对象时要递归复制它的子对象。因此在每次进行复制的时候都要调用递归函数，由此带来的额外负担不容忽视。比起这种递归算法，迭代算法更能高速地执行。此外，因为在每次递归调用时都会消耗栈，所以还有栈溢出的可能。

## 4.3 改进的方案

# 5. 标记压缩算法

## 5.1 基本原理

GC 标记-压缩算法(Mark Compact GC)是将 GC 标记-清除算法与 GC 复制算法相结合的产物。

GC 标记-压缩算法由标记阶段和压缩阶段构成。在 GC 标记-压缩算法中新空间和原空间是同一个空间。

压缩阶段并不会改变对象的排列顺序，只是把对象按顺序从堆各处向左移动到堆的开头。 这样就缩小了它们之间的空隙， 把它们聚集到了堆的一端。

### 5.1.1 标记阶段

首先是标记阶段。搜索根引用的对象及其子对象并打上标记，这里采用深度优先搜索。与标记清除算法相同。

<img src="http://123.57.190.49:12121/api/image/2060BVN4.png" title="" alt="" data-align="center">

### 5.1.2 压缩阶段

压缩过程会通过从头到尾按顺序扫描堆 3 次，第1次是对每个打上标记的对象找到它要移动的位置并记录在它们各自的成员变量forwarding里，第2次是重写所有活动对象的指针，将它们指向原位置的指针改为指向压缩后的对象地址，第3次是搜索整个堆，将活动对象移动到forwarding指针指向的位置完成对象的移动。

如图3.27所示，是第1次顺序扫描堆，对每个打上标记的对象，找到它要移动的位置并记录在它们各自的成员变量forwarding里。

<img src="http://123.57.190.49:12121/api/image/4R2J4HPR.png" title="" alt="" data-align="center">

第2次扫描堆，更新重写所有活动对象的指针，将它们指向原位置的指针改为指向压缩后的对象地址，如图3.28所示。

<img src="http://123.57.190.49:12121/api/image/V0F4FF40.png" title="" alt="" data-align="center">

第3次扫描堆，移动活动对象到其目的地址，完成对象的压缩过程。

<img src="http://123.57.190.49:12121/api/image/628HXBF0.png" title="" alt="" data-align="center">

三次堆扫描完成后，GC整个过程结束。GC结束状态如图3.30所示。

<img src="http://123.57.190.49:12121/api/image/F8826248.png" title="" alt="" data-align="center">

## 5.2 优缺点

**优点：**

1. 可有效利用堆。GC 标记-压缩算法和其他算法相比而言，堆利用效率高。GC 标记-压缩算法不会出现 GC 复制算法那样只能利用半个堆的情况。GC 标记-压缩算法可以在整个堆中安排对象，堆使用效率几乎是 GC 复制算法的 2 倍。

2. 没有GC标记-清除法所带来的碎片化问题。

**缺点：**

1. 压缩花费计算成本。压缩有着巨大的好处，但也有相应的代价。必须对整个堆进行 3 次搜索。执行该算法所花费的时间是和堆大小成正比的。

2. GC 标记-压缩算法的吞吐量要劣于其他算法。

## 5.3 改进

# 6. 保守式GC

## 6.1 基本概念

保守式 GC(Conservative GC)指的是“不能识别指针和非指针的 GC”。

如下图所示，在C/C++等高级语言的早期GC程序里，如果寄存器、函数调用栈或全局变量空间等这些根空间里有一个数值型的变量0x00d0caf0和一个指针的地址是相同的值0x00d0caf0，则程序无法识别这个值到底是数值变量还是指针。

对于貌似指针的非指针，为了避免错误回收导致程序故障，采取“宁可放过，不可杀错”的宽容原则，把它们当做活动对象而保留下来，像这样，在运行 GC 时采取的是一种保守的态度，即“把可疑的东西看作指针，稳妥处理”，所以我们称这种方法为“保守式 GC ”。

保守式GC的特点是尽量不移动对象的位置，因为容易把非指针重写从而产生意想不到的BUG。

## 6.2 优缺点

**优点：**

容易编写语言处理程序（语言处理程序是指将源程序转换成机器语言、以便计算机能够运行的汇编程序、编译程序和解释程序）。处理程序基本上不用在意 GC 就可以编写代码。语言处理程序的实现者即使没有意识到 GC 的存在，程序也会自己回收垃圾。因此语言处理程序的实现要比准确式 GC 简单。

这明显是一个设计缺陷，这优点写出来，有人信吗？

**缺点：**

1. 识别指针和非指针需要付出成本。在跟空间里，变量和指针的值相同的情况下，程序需要额外通过是否内存对齐、是否指向堆内对象的开头等手段来判断指针和非指针，成本较高。

2. 错误识别指针会压迫堆。当存在貌似指针的非指针时，保守式 GC 会把被引用的对象错误识别为活动对象。如果这个对象存在大量的子对象，那么它们一律都会被看成活动对象。这样容易留下较多的垃圾对象，从而会严重压迫堆。

3. 能够使用的 GC 算法有限。由于保守式GC的特点是尽量不移动对象的位置，因为容易把非指针重写从而产生意想不到的BUG。所以基本上不能使用 GC 复制算法等移动对象的 GC 算法。

## 6.3 改进方案

# 7. 分代垃圾回收

## 7.1 基本原理

分代垃圾回收中把对象分类成几代，针对不同的代使用不同的 GC 算法，我们把刚生成的对象称为新生代对象，到达一定年龄的对象则称为老年代对象。

由于新生代对象大部分会变成垃圾，如果应用程序只对这些新生代对象执行 GC，除了引用计数法以外的基本算法，都会进行只寻找活动对象的操作，如 GC 标记-清除算法的标记阶段和 GC 复制算法等。因此，如果很多对象都会死去，花费在 GC 上的时间应该就能减少。

我们将对新对象执行的 GC 称为新生代 GC(minor GC)。minor 在这里的意思是“小规模的”。 新生代 GC 的前提是大部分新生代对象都没存活下来，GC 在短时间内就结束了。

另一方面，新生代 GC 将存活了一定次数的新生代对象当作老年代对象来处理。 新生代对象上升为老年代对象的情况称为晋升(promotion)。

因为老年代对象很难成为垃圾，所以我们对老年代对象减少执行 GC 的频率。相对于新生代 GC，将面向老年代对象的 GC 称为老年代 GC(major GC)。

需要注意的是，分代垃圾回收不是跟 GC 标记-清除算法和 GC 复制算法并列在一起供开发人员选择的算法，而是需要跟这些基本算法一并使用。比如新生代GC使用GC复制算法，而老年代GC由于频率较低、可以使用最简单的GC标记-清除算法。

分代垃圾回收算法把对分成了四个空间，分别是生成空间、2 个大小相等的幸存空间以及老年代空间。新生代对象会被分配到新生代空间，老年代对象则会被分配到老年代空间里。

应用程序创建的新对象一般会放到新生代空间里，当生成空间满了的时候，新生代 GC 就会启动，将生成空间中的所有活动对象复制，这跟 GC 复制算法是一个道理，复制的目标空间是幸存空间。

2 个幸存空间和 GC 复制算法里的 From 空间、To 空间很像，我们经常只利用其中的一个。 在每次执行新生代 GC 的时候，活动对象就会被复制到另一个幸存空间里。在此我们将正在使用的幸存空间作为 From 幸存空间，将没有使用的幸存空间作为 To 幸存空间。

新生代 GC 也必须复制生成空间里的对象。 也就是说，生成空间和 From 幸存空间这两个空间里的活动对象都会被复制到 To 幸存空间里去——这就是新生代 GC。

只有从一定次数的新生代 GC 中存活下来的对象才会得到晋升，也就是会被复制到老年代空间去。

在执行新生代 GC 时需要注意，需要考虑到从老年代空间到新生代空间的引用。新生代对象不只会被根和新生代空间引用，也可能被老年代对象引用。因此，除了一般 GC 里的根，还需要将从老年代空间的引用当作根(像根一样的东西)来处理。

这里，使用记录集用来记录从老年代对象到新生代对象的引用。这样在新生代 GC 时就可以不搜索老年代空间的所有对象，只通过搜索记录集来发现从老年代对象到新生代对象的引用。

通过新生代 GC 得到晋升的对象把老年代空间占满后，就要执行老年代 GC 了。 老年代 GC 没什么难的地方，它只用到了3.1节的 GC 标记-清除算法。

<img src="http://123.57.190.49:12121/api/image/VJJVL0LL.png" title="" alt="" data-align="center">

## 7.2 优缺点

**优点：**

“很多对象年纪轻轻就会死”这一经验适合大多数情况，新生代 GC 只将刚生成的对象当成对象，这样一来就能减少时间上的消耗。 分代垃圾回收可以改善 GC 所花费的时间(吞吐量)。“据实验表明，分代垃圾回收花费的时间是 GC 复制算法的 1/4。”

**缺点：**

“很多对象年纪轻轻就会死”这个法则毕竟只适合大多数情况，并不适用于所有程序。对对象会活得很久的程序执行分代垃圾回收，就会产生以下两个问题。

* 新生代GC所花费的时间增多 

* 老年代GC频繁运行

## 7.3 改进方案

# 8. 增量式垃圾回收

## 8.1 基本概念

增量式垃圾回收(Incremental GC)是一种通过逐渐推进垃圾回收来控制应用程序最大暂停时间的方法。

增量(incremental)这个词有“慢慢发生变化” 的意思。就如它的名字一样， 增量式垃圾回收是将 GC 和应用程序一点点交替运行的手法。 增量式垃圾回收的示意图如图所示。

<img src="http://123.57.190.49:12121/api/image/ZN0X0HZ4.png" title="" alt="" data-align="center">

增量式垃圾回收也叫三色标记法(Tri-color marking)。本文中，增量式垃圾回收=三色标记法。

三色标记法是将对象根据搜索情况，分为三种颜色：

- 白色：还未搜索过的对象

- 灰色：正在搜索的对象

- 黑色：搜索完成的对象

GC 开始运行前所有的对象都是白色。GC 一开始运行，所有从根能到达的对象都会被标记，然后被堆到栈里。GC 只是发现了这样的对象，但还没有搜索完它们，所以这些对象就成了灰色对象。

灰色对象会被依次从栈中取出，其子对象也会被涂成灰色。当其所有的子对象都被涂成灰色时，对象就会被涂成黑色。

当 GC 结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾则为白色。

这就是三色标记算法的概念。

三色标记法和GC标记-清除算法结合起来增量式执行，就是我们本节要说的增量式垃圾回收，或叫增量式标记-清除算法。

增量式的 GC 标记-清除算法(三色标记法)可分为以下三个阶段。

- 根查找阶段 

- 标记阶段 

- 清除阶段

> 在我们介绍了这么多GC算法之后，我们终于终于到了Golang的GC算法了。

### 8.1.1 根查找阶段

在根查找阶段中，GC程序将直接从根引用的对象打上灰色标记，放到灰色队列里，将Root根对象本身标记为黑色对象。根查找阶段只在 GC 开始时运行一次。如下图所示。

<img src="http://123.57.190.49:12121/api/image/XFX840RZ.png" title="" alt="" data-align="center">

### 8.1.2 标记阶段

从灰色队列里取出对象，将其子对象涂成灰色，将该灰色对象本身标记为黑色。将这一系列操作执行 X 次，在这里“X 次”是重点，不是一次处理所有的灰色对象，而是只处理一定个数，然后暂停 GC，再次开始执行应用程序。这样一来，就能缩短应用程序的最大暂停时间。

<img src="http://123.57.190.49:12121/api/image/T84BJ8XV.png" title="" alt="" data-align="center">

将灰色队列里的所有灰色对象，通过多次搜索阶段、搜索并标记为黑色，完成后，意味着标记结束。标记结束时，灰色队列为空，所有灰色对象都成了黑色。这里，黑色对象意味着活动对象，白色对象意味着空闲对象，白色对象等待着在清除阶段被GC回收，也就是挂载到空闲链表上以供后面新对象分配使用。

<img src="http://123.57.190.49:12121/api/image/RT24Z0PH.png" title="" alt="" data-align="center">

### 8.1.3 清除阶段

在清除阶段，将黑色对象视为活动对象并保留，将白色对象挂载到空闲链表以清除，便于后面新对象分配时使用。

<img src="http://123.57.190.49:12121/api/image/6JDXR86R.png" title="" alt="" data-align="center">

三色标记清除算法本身是不可以并发或者增量执行的，它需要STW暂停应用程序，而如果并发执行，用户程序可能在标记执行的过程中修改对象的指针，容易把原本应该垃圾回收的死亡对象错误的标记为存活，或者把原本存活的对象错误的标记为已死亡，下面以后一种情况举例说明。

如下图所示。在一轮标记暂停的状态是：A 被涂成黑色，B 被涂成灰色进入灰色队列。所以下一轮标记，就要对 B 进行搜索了。如果在这两次标记之间，应用程序把从 A 指向 B 的引用更新为从 A 指向 C 之后的状态，然后再删除从 B 指向 C 的引用，如下图c)所示。这个时候如果重新开始标记， B 原本是灰色对象，经过搜索后被涂成了黑色。然而尽管 C 是活动对象，程序却不会对它进行搜索。这是因为已经搜索完有唯一指向 C 的引用的 A 了。

![](http://123.57.190.49:12121/api/image/NV0T60P0.png)

为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是**STW的过程有明显的资源浪费，对所有的用户程序都有很大影响**。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，就是屏障机制。

### 8.1.4 写入屏障

写入屏障的具体操作是：在 A 对象引用 C 对象的时候，C 对象被标记为灰色。(将 C 挂在黑色对象A的下游，C 必须被标记为灰色)

这一操作满足：不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色。

<img src="http://123.57.190.49:12121/api/image/22J2822L.png" title="" alt="" data-align="center">

## 8.2 优缺点

**优点：**

增量式垃圾回收不是一口气运行 GC，而是和应用程序交替运行的，因此不会长时间妨碍到应用程序的运行。

增量式垃圾回收适合那些比起提高吞吐量，更重视缩短最大暂停时间的应用程序。

**缺点：**

用到了写入屏障，就会增加额外负担。既然有缩短最大暂停时间的优势，吞吐量也一般。

## 8.3 改进方案

# 9. Go的GC

## 9.1 基本原理

go的GC本质上还是基于三色标记法的GC方案，go主要的改进方案是对写屏障的修改。

首先，我们在8.1.4章中提到的写屏障成为Dijkstra写屏障，也叫插入写屏障。在1.5-1.7版本，go使用插入写屏障，并且插入写屏障只在堆上使用。但因为插入写屏障带来的开销栈上的数据不接受。所以，对于栈上的数据需要进行STW暂停，来保证栈上的数据的三色一致性。

![](http://123.57.190.49:12121/api/image/66HJBFTJ.jpg)

![](http://123.57.190.49:12121/api/image/VZP2J2B0.jpg)

![](http://123.57.190.49:12121/api/image/06ZT8JH2.jpg)

![](http://123.57.190.49:12121/api/image/L44D204V.jpg)

![](http://123.57.190.49:12121/api/image/2XLDNZ64.jpg)

![](http://123.57.190.49:12121/api/image/BP6J8DNB.jpg)

![](http://123.57.190.49:12121/api/image/2Z2402JN.jpg)

![](http://123.57.190.49:12121/api/image/XZ66FLL6.jpg)

![](http://123.57.190.49:12121/api/image/4BXD286B.jpg)

![](http://123.57.190.49:12121/api/image/XHD4V4NV.jpg)

现在介绍另一种写屏障，删除写屏障。

被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。如下图所示，C 被 B 删除时，C 本身为白色，所以需要被标记为灰色。

![](http://123.57.190.49:12121/api/image/02PVPND2.jpg)

![](http://123.57.190.49:12121/api/image/8JRZF404.jpg)

![](http://123.57.190.49:12121/api/image/L220864B.jpg)

![](http://123.57.190.49:12121/api/image/8L262486.jpg)

![](http://123.57.190.49:12121/api/image/0R48H2PL.jpg)

![](http://123.57.190.49:12121/api/image/P2ZF0L6T.jpg)

![](http://123.57.190.49:12121/api/image/F6V0XPRH.jpg)

go将两种屏障结合，提出了混合写屏障。在垃圾收集的标记阶段，我们还需要**将创建的所有新对象都标记成黑色**，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。

混合写屏障的具体操作是：

1. GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2. GC期间，任何在栈上创建的新对象，均为黑色。

3. 被删除的对象标记为灰色。

4. 被添加的对象标记为灰色。

> 这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。

接下来，我们用几张图，来模拟整个一个详细的过程。

## 9.2 GC开始阶段

![](http://123.57.190.49:12121/api/image/N00X02N6.jpg)

![](http://123.57.190.49:12121/api/image/X022P284.jpg)

## 9.3 对象被一个堆对象删除引用，成为栈对象的下游

![](http://123.57.190.49:12121/api/image/08XLB6H8.jpg)

![](http://123.57.190.49:12121/api/image/P4ZDFHZ6.jpg)

## 9.4 对象被一个栈对象删除引用，成为另一个栈对象的下游

![](http://123.57.190.49:12121/api/image/60Z460F4.jpg)

![](http://123.57.190.49:12121/api/image/BZTXJ0N4.jpg)

![](http://123.57.190.49:12121/api/image/482L4PT4.jpg)

## 9.5 对象被一个堆对象删除引用，成为另一个堆对象的下游

![](http://123.57.190.49:12121/api/image/H8R046L8.jpg)

![](http://123.57.190.49:12121/api/image/024F66LD.jpg)

![](http://123.57.190.49:12121/api/image/V8RVL664.jpg)

## 9.6 对象从一个栈对象删除引用，成为另一个堆对象的下游

![](http://123.57.190.49:12121/api/image/6VN2D2XF.jpg)

![](http://123.57.190.49:12121/api/image/BXFFL644.jpg)

![](http://123.57.190.49:12121/api/image/04X66R6F.jpg)

## 9.7 Go的GC的流程

Go 语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段，它们分别完成了不同的工作[25](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:25)：

1. 清理终止阶段；
   1. **暂停程序**，所有的处理器在这时会进入安全点（Safe point）；
   2. 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2. 标记阶段；
   1. 将状态切换至 `_GCmark`、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；
   2. 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
   3. 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
   4. 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
   5. 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3. 标记终止阶段；
   1. **暂停程序**、将状态切换至 `_GCmarktermination` 并关闭辅助标记的用户程序；
   2. 清理处理器上的线程缓存；
4. 清理阶段；
   1. 将状态切换至 `_GCoff` 开始清理阶段，初始化清理状态并关闭写屏障；
   2. 恢复用户程序，所有新创建的对象会标记成白色；
   3. 后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；


